        -:    0:Source:example1.c
        -:    0:Graph:example1.gcno
        -:    0:Data:example1.gcda
        -:    0:Runs:12
        -:    1:// R Jesse Chaney
        -:    2:// rchaney@pdx.edu
        -:    3:
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <unistd.h>
        -:    7:#include <stdbool.h>
        -:    8:#include <libgen.h>
        -:    9:#include <errno.h>
        -:   10:#include <signal.h>
        -:   11:#include <getopt.h>
        -:   12:
        -:   13:// -n #  for the input number to calc the factorial
        -:   14:// -h    show some, lame, help
        -:   15:// -v    show a little verbosity
        -:   16:// -s    call pause() and await a signal to continue. See the
        -:   17://           signal_handler function for how signals are handled
        -:   18:#define OPTIONS "n:hvs"
        -:   19:#define ENEG_VALUE 2
        -:   20:#define ETOOOOOOOBIG_VALUE 3
        -:   21:#define SIGNALS 1
        -:   22:
        -:   23:static bool is_verbose = false;
        -:   24:
        -:   25:long factorial(long n);
        -:   26:
        -:   27:#ifdef SIGNALS
        -:   28:void signal_handler(int);
        -:   29:
        -:   30:void
        5:   31:signal_handler(int sig)
        -:   32:{
        5:   33:	switch(sig) {
        1:   34:	case SIGINT:
        1:   35:		fprintf(stderr, "%d: a SIGINT was received\n", __LINE__);
        1:   36:		break;
        1:   37:	case SIGQUIT:
        1:   38:		fprintf(stderr, "%d: a SIGQUIT was received\n", __LINE__);
        1:   39:		break;
        1:   40:	case SIGHUP:
        1:   41:		fprintf(stderr, "%d: a SIGHUP was received\n", __LINE__);
        1:   42:		break;
        1:   43:	case SIGUSR1:
        1:   44:		fprintf(stderr, "%d: a SIGUSR1 was received\n", __LINE__);
        -:   45:		[[fallthrough]];  // Explicitly marks intentional fallthrough
        2:   46:	case SIGUSR2:
        -:   47:	default:
        2:   48:		fprintf(stderr, "%d: Signal %d received\n", __LINE__, sig);
        2:   49:		break;
        -:   50:	}
        5:   51:}
        -:   52:#endif // SIGNALS
        -:   53:
        -:   54:long
       10:   55:factorial(long n)
        -:   56:{
       10:   57:	long result = 1;
        -:   58:	
       10:   59:	if (is_verbose) {
        3:   60:		fprintf(stderr, "%d: entering %s with input %ld\n"
        -:   61:				, __LINE__, __FUNCTION__, n);
        -:   62:	}
       10:   63:	errno = 0;
       10:   64:	if (n < 0) {
        2:   65:		errno = ENEG_VALUE;
        2:   66:		return -1; // Error for negative input
        -:   67:	}
        8:   68:	if ((n == 0) || (n == 1)) {
        6:   69:		return 1;
        -:   70:	}
        -:   71:
       25:   72:	for (int i = 2; i <= n; i++) {
       24:   73:		result *= i;
       24:   74:		if (result < 0) {
        -:   75:			// overflow
        1:   76:			errno = ETOOOOOOOBIG_VALUE;
        1:   77:			break;
        -:   78:		}
        -:   79:	}
        -:   80:
        2:   81:	if (is_verbose) {
        2:   82:		fprintf(stderr, "%d: exiting %s with result %ld\n"
        -:   83:				, __LINE__, __FUNCTION__, result);
        -:   84:	}
        -:   85:	
        2:   86:	return result;
        -:   87:}
        -:   88:
        -:   89:int
       12:   90:main(int argc, char *argv[])
        -:   91:{
       12:   92:	long value = 0;
        -:   93:
        -:   94:#ifdef SIGNALS
       12:   95:	signal(SIGINT, signal_handler);
       12:   96:	signal(SIGQUIT, signal_handler);
       12:   97:	signal(SIGHUP, signal_handler);
       12:   98:	signal(SIGUSR1, signal_handler);
       12:   99:	signal(SIGUSR2, signal_handler);
        -:  100:#endif // SIGNALS
        -:  101:	{
       12:  102:		int opt = 0;
        -:  103:
       24:  104:		while ((opt = getopt(argc, argv, OPTIONS)) != -1) {
       14:  105:			switch (opt) {
        4:  106:			case 'n':
        4:  107:				int result = sscanf(optarg, "%ld", &value);
        4:  108:				if (result < 1) {
    #####:  109:					fprintf(stderr, "Invalid value for input: %s\n", optarg);
    #####:  110:					exit(EXIT_FAILURE);
        -:  111:				}
        4:  112:				break;
        3:  113:			case 'v':
        3:  114:				is_verbose = true;
        3:  115:				break;
        1:  116:			case 'h':
        1:  117:				fprintf(stderr, "Help is on the way\n\tUsage: %s %s\n"
        -:  118:						, basename(argv[0]), OPTIONS);
        1:  119:				exit(EXIT_SUCCESS);
        -:  120:				break;
        5:  121:			case 's':
        5:  122:				pause();
        5:  123:				break;
        1:  124:			default:
        1:  125:				fprintf(stderr, "Bad arguement\n\tUsage: %s %s\n"
        -:  126:						, basename(argv[0]), OPTIONS);
        1:  127:				exit(EXIT_FAILURE);
        -:  128:			}
        -:  129:		}
        -:  130:	}
        -:  131:
        -:  132:	{
       10:  133:		long *fact = malloc(sizeof(long));
       10:  134:		if (fact == NULL) {
    #####:  135:			perror("malloc failed");
    #####:  136:			fprintf(stderr, "%d: malloc failed\n", __LINE__);
    #####:  137:			exit(EXIT_FAILURE);
        -:  138:		}
       10:  139:		*fact = factorial(value);
       10:  140:		if (errno != 0) {
        3:  141:			fprintf(stderr, "Invalid input: %ld\n", value);
        3:  142:			exit(EXIT_FAILURE);
        -:  143:		}
        7:  144:		printf("Factorial of %ld: %ld\n", value, *fact);
        7:  145:		free(fact);
        -:  146:	}
        -:  147:
        7:  148:	return EXIT_SUCCESS;
        -:  149:}
